
\documentclass[a4paper]{report}
% \documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{esint}
\usepackage{tabstackengine}
\usepackage[colorlinks,linkcolor=blue]{hyperref}
\usepackage{xeCJK}
\usepackage{caption}
\usepackage{stackengine}
\usepackage{graphicx}
\graphicspath{ {../resources/figure/dsp/} }
\usepackage{float}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{amsfonts}
\usepackage{blkarray}
\usepackage{enumitem}
\setlist[1]{itemsep=-5pt}
\usepackage{subcaption}

\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{pgfplots}
\usepackage{mathrsfs}
\usepackage{diagbox}
\usepackage{minted}

\usetikzlibrary{shapes,arrows,positioning}
\captionsetup[table]{skip=10pt}

%%%% 下面的命令重定义页面边距，使其符合中文刊物习惯 %%%%
\addtolength{\topmargin}{-54pt}
\setlength{\oddsidemargin}{0.63cm}  % 3.17cm - 1 inch
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textwidth}{14.66cm}
\setlength{\textheight}{24.00cm}    % 24.62


% 段首不缩进
\setlength{\parindent}{0pt}
%%%% 下面的命令设置行间距与段落间距 %%%%
\linespread{1.2}
% \setlength{\parskip}{1ex}
\setlength{\parskip}{.5\baselineskip}

\def\rlwd{.5pt} \def\rlht{2.2ex} \def\rldp{.5ex}
\def\mydiv#1{~%
  \rule[-\rldp]{\rlwd}{\rlht}%
  \setbox0=\hbox{~#1}%
  \stackunder[\dimexpr\rldp-\rlwd]{~#1}{\rule{\wd0}{\rlwd}}%
}

\title{DSP}
\author{Crosstyan}
\date{Dec 2020}


\begin{document}
\chapter{Hardware}
对于RAM, 一个单元相当于一个Byte. (8位单片机)
\begin{itemize}
  \item 256 Byte RAM (内部数据存储器)
  \item 4 KByte ROM (内部程序存储器) 用于存放程序和原始数据
\end{itemize}
\section{引脚}
引脚简介
\begin{itemize}
  \item 有$8 \times 4$个GPIO, 每组有8个$PX.0\sim PX.7$ (0至7), 有四组$P0\sim P3$ (0至3)
  \item 外部ROM读选通信号 $\overline{PSEN}$ 低电平有效, 片外ROM读取. 通常是高电平使用片内. 
  \item 地址锁存控制信号 $ALE$ 片外ROM和RAM使用, 丢到Latch
  \item $\overline{EA}$ 低电平为外部ROM, 高电平为内部ROM开始. 
  \item $RST$ 顾名思义, 复位. 需要俩机器周期以上的\textbf{高电平}
\end{itemize}
\paragraph{Address Bus (AB)}
\begin{itemize}
  \item $P0$ 除了用作GPIO以外还能作为Address Bus, 提供低八位地址
  \item $P2$ 提供高八位地址
  \item 最大可以访问到$2^{16}$ bit, 也就是64 KByte的地址范围
\end{itemize}
\paragraph{Data Bus} $P0$ 除了GPIO, AB之外还能提供8 bit的数据
\paragraph{Control Bus} 控制总线

如$P3$除了作为GPIO还有很多第二功能. 
\section{RAM分区}
分为低128 Byte和高128 Byte. 

只有低128 Byte ($00H\sim 7FH$) 能被用户使用, 高128 Byte ($80H\sim FFH$) 被SFR占用. 

低128 Byte (内部RAM区)又能被分为三部分
\begin{itemize}
  \item $00H\sim 1FH$ 工作寄存器 (又被分成四组等分)
  \item $20H\sim 2FH$ 位寻址区
  \item $30H\sim 7FH$ 数据缓存 (堆栈)
\end{itemize}

\subsection{Register区}
工作寄存器(32 Byte)被四等分, 每组有8 Byte, 每Byte相当于一个寄存器, 在组内按$R0\sim R7$编号. 其组的选择由$RS
0$和$RS1$决定. 
\subsection{Bit 寻址区}
在$20H\sim 2FH$之间, 每一个Bit都可以进行位操作(不再是以Byte为操作单位, 虽然也可以以Byte为操作单位)

% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{table}[H]
  \centering
  \caption{位地址表}
    \begin{tabular}{c|llll}
      \diagbox{位数}{Bit 地址}{Byte 地址}    &  32 (20H) & 33 (21H) & …     & 47 (2FH) \\
          \hline
    $D_0$    & 0 (00H)     & 8 (08H)     & …     & 120 (78H) \\
    $D_1$    & 1     & 9     & …     & 121 \\
    $D_2$    & 2     & 10    & …     & 122 \\
    $D_3$    & 3     & 11    & …     & 123 \\
    $D_4$    & 4     & 12    & …     & 124 \\
    $D_5$    & 5     & 13    & …     & 125 \\
    $D_6$    & 6     & 14    & …     & 126 \\
    $D_7$    & 7 (07H)     & 15 (0FH)   & …     & 127 (7FH) \\
    \end{tabular}%
  \label{tab:bit_addr}%
\end{table}%
\subsection{用户RAM区}
只能以储存单元的形式来使用, 直接Byte 寻址 (30H$\sim$7FH) 或者用堆栈. 
\section{SFR和其他特殊寄存器}
\subsection{A 累加器}
$A_{cc}$ (8 bit). 需要Arithmetic Logic Unit处理的数据和计算结果多数要经过此处. 

存放操作数和运算结果. 
\subsection{B Register}
同样是8 bit, 和A配合使用. 
\begin{itemize}
  \item 乘法时B为乘数并且存放乘积的高八位
  \item 除法时为除数并存放余数
\end{itemize}
\subsection{程序计数器}
The program counter (PC), commonly called the instruction pointer (IP) in Intel x86 and Itanium microprocessors

16 bit, 唯一不可寻址的Register, 不属于SFR. 

在执行转移, 调用返回的指令时能自动改变其内容, 以改变程序的执行顺序. 复位时$PC=0000H$. 
\subsection{程序状态字}
PSW, 8 bit. 存放ALU运算过程的标志状态和一些其他玩意. 每个bit代表不同的状态. 
\begin{table}[H]
  \centering
  \begin{tabular}{c|cccccccc}
    bit & 7&6&5&4&3&2&1&0
    \\ Flag &CY&AC&FO&RS1&RS0&OV&-&P
    \\ 意义 &进位&半进位&用户定义&寄存器组&寄存器组&溢出&未使用&奇偶
  \end{tabular}
  \caption{PSW各bit所表示的状态}
  \label{tab:psw}
\end{table}
\begin{itemize}
  \item CY: 加减法存放进位和借位
  \item AC: 第4 bit对高4 bit 有进位或者借位
  \item F0: 没啥卵用
  \item OV: OV=1 加减中表示运算结果超过A (1 byte=8 bit) 的范围; 乘法表示乘积存储在A和B中; 除法表示除数为0. 
  \item P: 奇偶标志位, 累加器A中, bit 为 1 的个数. 若 1 的个数为偶数则 P = 0. 
\end{itemize}
\begin{table}[H]
  \centering
  \begin{tabular}{ccccc}
      RS1&RS0&寄存器组&片内RAM地址&通用寄存器名
    \\0&0&0&00H$\sim$07H&R0$\sim$R7
    \\0&1&1&08H$\sim$0FH&R0$\sim$R7
    \\1&0&2&10H$\sim$17H&R0$\sim$R7
    \\1&1&3&18H$\sim$1FH&R0$\sim$R7
  \end{tabular}
  \caption{RS1和RS0对寄存器组的选择}
\end{table}
\subsection{DPTR}
用于存放片外储存器. 

可以作为16 bit的寄存器或者俩8 bit寄存器 (分别称作DPL和DPH)
\subsection{堆栈指针}
SP

系统复位时, $SP=07H$, 实际使用时一般设置在30H (用户RAM, 即30H$\sim$7FH) 之后. FILO. First in, Last out. 
\section{ROM分区}
\begin{itemize}
  \item 0H$\sim$2H 启动单元
  \item 3H$\sim$AH 外部中断0 (8 Byte)
  \item BH$\sim$12H 定时器/计数器0 (8 Byte)
  \item 13H$\sim$1AH 外部中断1
  \item 1BH$\sim$22H 定时器/计数器1
  \item 23H$\sim$2AH 串行中断地址区
\end{itemize}
\section{时钟与复位}
\subsection{内部震荡}
\subsection{外部震荡}
常用于多块芯片同时工作, 便于同步
\subsection{时序}
若外接晶振为振荡频率12MHz. (设为$f$)
\begin{itemize}
  \item 震荡周期$T=\frac{1}{f}$
  \item 时钟周期$T_{\text{clock}}=2\cdot T$
  \item 机器周期$T_{\text{8051}}=6\cdot T_{\text{clock}}=12\cdot T$
  \item 指令周期, 具体看是什么指令, 消耗$T_{8051}\sim 4\cdot T_{8051}$
\end{itemize}
\subsection{复位}
RST至少保持两个机器周期$T_{8051}=12\cdot T$的高电平
\chapter{汇编}
\section{指令分类}
\subsection{按执行时间分类}
\begin{itemize}
  \item 单机器周期
  \item 双机器周期
  \item 四机器周期
\end{itemize}
\subsection{按占用ROM}
\begin{itemize}
  \item 1 Byte
  \item 2 Byte
  \item 3 Byte
\end{itemize}
\section{基本格式}
助记符 <目的操作数(左值)> 逗号「,」 <源操作数 (右值)>
\begin{itemize}
  \item $R_n$ 当前寄存器组中的工作寄存器$R0\sim R7$
  \item $R_i$ 特指两个可以用于间接Addressing的Register: $R0$和$R1$.
  \item 不带$\#$ (Sharp) 的统统指的是内部RAM的地址; 可以是2 Byte或者4 Byte, 也可以直接写GPIO组$P1$, 或者SFR如$A$
  \item 带$\#$ 的都是一个数字, 或者叫做立即数
\end{itemize}
\section{伪指令}
\subsection{ORG}
如果不用ORG, 那在ROM中会从0000H开始. 不过一般都会加上ORG使其从2000H开始\footnote{为啥非得是2000H? 传统罢, 你想在ROM里面的任何一个空间理论上都是可以的}
\subsection{END}
在一个ORG中只能存在一条END命令
\subsection{EQU}
类似于define, 和MOV不同, 相当于全局替换. 

<字符名称> EQU <被替换的玩意>
\subsection{DB}
Define Byte. ROM连续单元内定义8 bit的数字. 

连续单元储存数据
\section{Addressing}
\subsection{Register Addressing}
\begin{minted}{gas}
  MOV A,R0
\end{minted}
等价于
\begin{minted}{cpp}
  register.A=register.R0;
\end{minted}



\subsection{Direct Addressing}
\begin{minted}{gas}
  MOV A,3AH
\end{minted}
等价于
\begin{minted}{cpp}
  register.A= *(0x3a);
\end{minted}

只限于内部RAM, 直接寻址是访问SFR的唯一方法. 
\subsection{Immediate/literal Addressing}
\begin{minted}{gas}
  MOV A,#3AH
\end{minted}
等价于
\begin{minted}{cpp}
  register.A= 0x3a;
\end{minted}
当const为16 bit时只能赋给DPTR
\begin{minted}{gas}
  MOV DPTR,#003AH
\end{minted}
\subsection{Bit Addressing}
当左值和右值都是一个bit的时候, 可以进行位寻址; 和直接寻址类似. 
\begin{minted}{gas}
  MOV C, 3AH
\end{minted}
等价于
\begin{minted}{cpp}
  register.C= *(0x3a);
\end{minted}
此处3AH存放的是bit 地址 (参照上文bit 地址表\ref{tab:bit_addr}); 因为左值是一个代表bit的寄存器, 所以右值自动到bit 地址去寻址而非内部RAM的Byte. 

或者也可以用Byte地址加上位数来寻址. 如bit 地址3AH代表的Byte 地址的是「27H.2」
\subsection{Indirect Addressing}
\begin{minted}{nasm}
  MOV R0, 3AH
  MOV A, @R0
\end{minted}
等价于
\begin{minted}{cpp}
  //0x3a里边存着啥我们不知道
  register.R0=0x3a;
  register.A= *(register.R0); //A就等于0x3a里边存的玩意
\end{minted}
若是
\begin{minted}{nasm}
  MOV R0, 3AH
  MOV A, R0
\end{minted}
\begin{minted}{cpp}
  register.R0=0x3a;
  register.A= register.R0; // A=0x3a
\end{minted}
内部RAM低128 Byte只能使用$R0$或者$R1$作为间接寻址寄存器. 

外部RAM那就只能用DPTR
\subsection{变址寻址}
一般是$@A+DPTR$或者$@A+PC$, 这是为了访问\textbf{程序存储器}即ROM里面的数据表格

DPTR放表的首地址, A为所查数据的偏移. 
\begin{minted}{nasm}
  MOVC A, @A+DPTR
\end{minted}
\begin{minted}{cpp}
  register.A= *(register.A+register.DPTR); // A为ROM中(A+DPTR)地址里面的内容
\end{minted}
\section{指令介绍}
\subsection{数据传送类}
\subsubsection{MOV 赋值}
左值等于右值. 
\paragraph{左值为A} 右值可以为
\begin{itemize}
  \item 寄存器
  \item 直接寻址
  \item 间接寻址
  \item 立即数
\end{itemize}
\paragraph{左值为寄存器}$R_n$, 右值可以为
\begin{itemize}
  \item A
  \item 直接寻址
  \item 立即数
\end{itemize}
\paragraph{左值为内存地址}, 右值为
\begin{itemize}
  \item A
  \item 寄存器
  \item 直接寻址
  \item 间接寻址
  \item 立即数
\end{itemize}
\paragraph{左值为间接寻址}$@R_i$, 右值为
\begin{itemize}
  \item A
  \item 直接寻址
  \item 立即数
\end{itemize}
注意左值和右值不可以同时存在通用寄存器, 因为一条指令中左值或者右值通用寄存器$R_n$只能出现一次. 也就是说不可能出现寄存器R1的值赋给R2, 当然间接寻址也不行. 
\paragraph{左值为DPTR} 右值为16 bit立即数, 等价于向DPH传8 bit (1 byte)高位, 向DPL传1 byte低位. 
\begin{minted}{nasm}
  MOV DPTR, #2368H

  MOV DPH, #23H
  MOV DPL, #68H
\end{minted}
\subsubsection{MOVC 读ROM}
查表指令, 或者说从ROM拉取数据到RAM里面, 只能读不能写. 左值只能是累加器A, 右值为(@A+DPTR)或者(@A+PC)间接到ROM寻址. 
\subsubsection{MOVX 读写片外RAM}
读片外RAM时, 左值为累加器A, 右值为DPTR间接寻址或者寄存器$R_i$间接寻址

写片外RAM时, 右值为累加器A, 左值为DPTR间接寻址或者寄存器$R_i$间接寻址

不可以直接寻址, 必须把地址写入寄存器或者DPTR之中再利用间接寻址
\subsubsection{XCH Byte 交换指令, 只能在片内RAM}
左值只能是寄存器A, 右值可以是寄存器$R_n$, 直接寻址或者间接寻址$@R_i$
\subsubsection{XCHD 低半 Byte 交换}
\subsubsection{SWAP 交换 Byte 中的高低位}
看作是只接收单参数的函数或者啥的, 但是这个参数只能是累加器A. 将累加器A的Byte 的高4 bit和低4 bit互换. 
\subsubsection{PUSH和POP}
单参数函数, 参数只能是直接寻址, 不能是寄存器, 也不能是间接寻址(因为这牵扯到了寄存器所以也是NG)

如果是累加器A作为参数的话只能用ACC替代 (A是寄存器名, ACC是其在片内RAM的地址)

\paragraph{PUSH} 堆栈指针SP自加1, 然后堆栈指针所指内存内容为直接寻址内容
\begin{minted}[]{cpp}
  register.SP++;
  *(register.SP)= *(addr);
\end{minted}
\paragraph{POP} 堆栈指针所指内存内容为直接寻址内容, 堆栈指针SP自减1
\begin{minted}[]{cpp}
  *(addr)=*(register.SP);
  register.SP--;
\end{minted}
\subsection{算术指令}
参加表\ref{tab:psw}

\subsubsection{ADD 非进位加法}
左值只能是累加器A, 同时也是加数, 右值是被加数. 结果存放于A之中. 

右值可以是寄存器, 直接寻址, 间接寻址, 立即数. 
\begin{minted}{nasm}
  ADD A, R0
\end{minted}
\begin{minted}[]{cpp}
  register.A+=register.R0;
\end{minted}
\subsubsection{ADDC 带进位加法}
\begin{minted}[]{cpp}
  bit C=psw.cy;
  register.A+=register.R0;
  register.A+=C;
\end{minted}
\subsubsection{SUBB 带借位减法}
% \begin{minted}[]{cpp}
%   register.A-=register.R0;
% \end{minted}
\subsubsection{INC 自增}
参数可以是A, 寄存器, 直接寻址, 间接寻址和DPTR. 

只会影响PSW内的P. 
\subsubsection{DEC 自减}
参数可以是A, 寄存器, 直接寻址, 间接寻址. \textbf{但不能是DPTR}
\subsubsection{DA 变成BCD码}
参数只能是A. 
\subsubsection{MUL 乘法}
\begin{minted}{nasm}
  MUL AB
\end{minted}
无符号乘法, 乘数放在A, 被乘数放在B. 结果若小于1 Byte (255)则B=0; 否则B存放高4 bit. 

\subsubsection{DIV 除法}
无符号乘法, 除数放在A, 被除数放在B. B不能为0. 
\subsubsection{ANL AND}
左值只能是累加器A或者直接寻址; 右值可以为寄存器, 直接寻址, 间接寻址, 立即数(但是不能左右值相同啦)
\subsubsection{ORL OR}
同上
\subsubsection{XRL XOR}
同上
\subsubsection{CLR 清零 (参数只能是A)}
参数只能为A
\subsubsection{CPL 取反 (参数只能是A)}
参数只能为A
\subsubsection{移位}
参数只能是A
\begin{itemize}
  \item RL 循环左移
  \item RR 循环右移
  \item RLC 带进位循环左移
  \item RRC 带进位循环右移
\end{itemize}
左移乘2, 右移除以2. 
\subsection{控制转移指令}
\subsubsection{无条件转移}
\paragraph{LJMP (Long Jump)}
参数为ROM地址 16 bit. (但是一般就直接写标号)
\paragraph{AJMP (Absolute Jump)}
参数为ROM地址 11 bit (但是一般就直接写标号, 没啥卵用)
\paragraph{SJMP (Short Jump)} 给我用LJMP
\paragraph{JMP (Jump)} 给我用LJMP
\subsubsection{条件转移}
\paragraph{JZ}
参数为偏移量 (offset), 但一般直接写标号
\begin{minted}{cpp}
  if (register.A==0){
    goto offset;
  }else{
    //往下执行
  }
\end{minted}

\paragraph{JNZ}一般直接写标号
\begin{minted}{cpp}
  if (register.A!=0){
    goto offset;
  }else{
    //往下执行
  }
\end{minted}
% \subsubsection{循环的写法}
% \begin{minted}{nasm}
% LOOP1:  ;DO SOMETHING
%         ;JUST DO SOMETHING TO A
%         JZ TAG1 ;if A=0, goto TAG1
% LJMP LOOP1
% TAG1:   RET
% \end{minted}

% \begin{minted}{cpp}
% loop1: //do something
%   if (register.A=0){
%     goto loop1;
%   }
% \end{minted}

\subsubsection{CJNE 比较转移指令}
三参数; 左值可以为A或者寄存器 (不能为直接寻址), 右值可以为直接寻址或者立即数. (一般都是立即数啦)
\begin{minted}{nasm}
  CJNE A,#10H, YOU_WANNA_GO_THIS_TAG
\end{minted}
本质上是做了一个减法, 若左值不等于右值则跳转. 
\begin{minted}{cpp}
  if (register.A!=0x10){
    goto you_wanna_go_this_tag;
  }
\end{minted}
\subsubsection{DJNZ 减一非零条件转移指令}
俩参数; 固定减一. 可以为寄存器或者直接寻址(不能为A). 
\begin{minted}{cpp}
register.R0--;
if (register.R0!=0){
  goto you_wanna_go_this_tag;
}
\end{minted}
经常用来写for循环. 
\subsubsection{程序调用返回}
\paragraph{LCALL}长调用
\paragraph{ACALL}绝对调用
\paragraph{RET}子程序返回
\paragraph{RETI}中断服务子程序返回
\paragraph{NOP}循环, 没有参数. 闲置一个机器周期什么都不做. 
\paragraph{例子}设计程序, 从P1.1输出10个方波, 每个方波周期为10个周期. 
\begin{minted}{cpp}
register.R2=20;
do{
  ~register.P1.1; //1T
  NOP(); //1T
  NOP(); //1T
  register.R2--; //1T
}while(R2!=0); //判断也要1T
\end{minted}
\begin{minted}{nasm}
      MOV R2,#20
LOOP: CPL P1.1 ;1T
      NOP      ;1T
      NOP      ;1T
      DJNZ R1, LOOP ;2T
\end{minted}
\subsection{Bit 操作}
\begin{itemize}
  \item CLR 置零
  \item CPL 取反
  \item SETB 置一
\end{itemize}
\subsubsection{位条件转移指令}
判断C值(CY标志位), 即PSW.CY里面的
\begin{itemize}
  \item JC
  \item JNC
  \item JB 俩参数
  \item JNB
  \item JBC 清零
\end{itemize}
\chapter{程序结构设计}
\section{顺序}
ORG, 标号MAIN, 走起. 
\section{分支}
CJNE, DJNZ. 

\subsection{多分支}
JMP @A+DPTR, 和数据表(存放相对地址)配合
\section{循环}
\begin{itemize}
  \item 设置循环初值
  \item 循环体
  \item 修改循环参数
  \item 循环控制部分
\end{itemize}
\subsection{循环嵌套}
多重循环定时程序.

因为Register最大为8 bit (255), 需要双重甚至多重循环. 

\begin{minted}{nasm}
TIME1 EQU 10
TIME2 EQU 20
        MOV R5,#TIME1
LOOP2:  MOV R4,#TIME2 ;1T

;LOOP1 START
LOOP1:  NOP ;1T
        NOP ;1T
        DJNZ R4, LOOP1 ;2T
;LOOP1 END

        DJNZ R4, LOOP2 ;2T
        RET
\end{minted}
所花费时间为
\begin{equation}
  T_{8051}=12\cdot T_{\text{oscillator}}
\end{equation}
\begin{equation}
  (T_2\cdot \underset{\text{2NOP+DJNZ}}{4}+\underset{\text{DJNZ}}{2}+\underset{\text{MOV}}{1})\cdot T_1\cdot T_{8051}
\end{equation}
等价于以下程序
\begin{minted}{cpp}
#define TIME1 10
#define TIME2 20

register.R5=TIME1;
do{
  register.R4=TIME2;
  //LOOP 1 START
  do{
    NOP();
    NOP();
    register.R4--;
  }while(register.R4!=0);
  //LOOP 1 END
  register.R5--;
}while(register.R5!=0);
\end{minted}
\section{二进制与BCD转换}
\chapter{中断}
\section{中断源}
\begin{itemize}
  \item 外部中断0
  \item 定时器中断$T_0$
  \item 外部中断1
  \item 定时器中断$T_1$
  \item 串行口 RX, TX
\end{itemize}
\subsection{外中断源}
低电平触发方式和负跳脉冲触发方式
\subsection{定时器/计数器中断}
内部计数器计数溢出, 溢出标志位作为单片机接受中断请求标志

信号来源于内部便是定时器, 外部为计数器. 
\subsection{串行中断}
\section{中断控制}
\subsection{IE}
中断允许控制寄存器IE, 复位时IE=00H. 
\begin{table}[H]
  \centering
  \begin{tabular}{c|cccccccc}
    bit & 7&6&5&4&3&2&1&0
    \\ Flag &EA&-&-&ES&ET1&EX1&ET0&EX0
    \\ 意义 &使能&-&-&串行&内中断1&外中断1&内中断0&外中断0
  \end{tabular}
  \caption{IE各bit所表示的状态}
  \label{tab:ie}
\end{table}
\subsection{TCON}
定时器控制寄存器TCON

TF0, TF1为定时器溢出中断请求标志位. 有两种操作
\begin{itemize}
  \item 软件查询时, 若查询有效则用户软件清零. 
  \item 中断方式, 作为中断请求标志位, 为1时自动转向中断服务程序, 由硬件来自动清零
\end{itemize}

\subsection{SCON}
Serial相关. 

\subsection{IP}
中断优先级控制寄存器

同级查询次序为: 外0, 内0, 外1, 内1, 串行. 

一个中断请求已经被响应则其他同级中断响应被禁止; 只有高优先级的中断请求才能打断低优先级的. 

\section{中断服务}
从入口地址开始执行直到$RETI$
\subsection{现场保护和恢复}
中断时刻MCU存储单元中的数据和状态, 一定是主程序和中断程序都用到并且不能被修改的存储单元. 
\begin{itemize}
  \item 保护: 位于中断处理程序的首部, PUSH操作数
  \item 恢复: 位于中断处理程序的尾部, POP操作数
\end{itemize}
\subsection{开关中断}
在中断处理程序中, 关中断, 禁止响应其他一切中断. 

在现场保护和现场恢复前后加上关中断和开中断, 避免现场被破坏. 

中断处理程序的最后一条指令一定是RETI
\section{处理套路}
% \begin{minted}{nasm}
%       ORG 0000H
%       LJMP MAIN
%       ORG 0003H ;跳转至对应中断入口地址
%       LJMP INTERRUPTION_TAG
% MAIN: ;WRITE SOMETHING
%       SJMP SOME_WHERE
% \end{minted}
二极管共阳, 即阴极对准MCU引脚, 那么就需要引脚为低电平才会亮. 

中断$\overline{INT0}$, 高电平不触发, 低电平触发 (或者由高电平跳至低电平)
\paragraph{例题}P1接8个LED左移右移发光流水灯, 当中断$\overline{INT0}$触发时使得8个LED闪烁5次. 
\begin{minted}[]{nasm}
      ORG 0000H
      LJMP MAIN ; Go here When MCU starts. 
      ORG 0003H
      LJMP EXT0 ; Go here when the interruption is triggered. 

      ORG 0030H ; MAIN starts at 0x0030
MAIN: SETB EA ; 套路, 开总开关
      SETB EX0 ;套路, 开外部中断0开关
      ; 如果你想的话可以直接设IE一位一位对着调
      MOV SP, #70H ; 套路, SP默认是在0x20; 我们一般让其从0x70开始
LOOP: MOV A, #0FFH ; register.A=0b11111111
      MOV R2, #08H ; register.R2=8
      CLR C ;把bit PSW.CY=0

LEFT: RLC A ;别被标志骗了, 如果没有跳转的话你始终是从上往下执行的
      MOV P1, A ;让P1口按照A来输出
      ACALL DELAY ; 相当于调用一个没有参数也没有返回值的函数 delay() 由下文定义
      DJNZ R2, LEFT ; register.R2--; while(register.R2!=0)
      MOV R2, #07H
RIGHT:RRC A
      MOV P1, A
      ACALL DELAY
      DJNZ R2,RIGHT
      AJMP LOOP ;相当于while(1)的死循环
\end{minted}
等价的C伪代码如下
\begin{minted}{cpp}
void main(){
  register.IE.EA=1;
  register.IE.EX0=1;
  register.SP=0x70;
  do{ //LOOP
    register.A=0b11111111;
    register.R2=8;
    register.PSW.CY=0;
    do{ //LEFT
      RLC(A); //严格来说C语言有自己的右移运算符, 但是我们没有带进位PSW.CY的函数
      register.P1=A;
      delay();

      register.R2--;
    }while(register.R2!=0)
    register.R2=7;
    do{ //RIGHT
      RRC(A);
      register.P1=A;
      delay();

      register.R2--;
    }while(register.R2!=0)
  }while(1)
}
\end{minted}
接下来是写中断相关的程序EXT0
\begin{minted}{nasm}
  EXT0: PUSH ACC ;保护现场, 注意没有PUSH A(寄存器名)
        PUSH PSW

        SETB RS0
        CLR RS1 ;新开一组Register组

        MOV A, #00H ;register.A=0b00000000
        MOV R2, #10 ;register.R2=10 亦可以写作0AH
  BLINK:MOV P1, A
        ACALL DELAY
        CPL A
        DJNZ R2, BLINK ;亮灭10次相当于闪烁5次

        POP PSW
        POP ACC
        RETI
\end{minted}
等价的C伪代码如下
\begin{minted}{cpp}
  void ext0(){
    push(ACC); //ACC is a const. the address of A
    push(PSW);
    register.PSW.RS0=1;
    register.PSW.RS1=0;//选中寄存器组(01)

    register.A=0b00000000;
    register.R2=10;
    do{//BLINK
      register.P1=register.A;
      delay();
      ~register.A;
    }while(register.R2!=0);
    pop(ACC);
    pop(PSW);
  }
\end{minted}
延时子程序, 根据时钟周期来设定大致的延时时间. 
\chapter{定时/计数器}
定时功能是通过本身的机器周期乘上计数次数实现的. 
必须由CPU来初始化定时/计数器. 
\section{定时/计数器相关寄存器}
\subsection{TCON}
\begin{itemize}
  \item TF1 (TCON.7) 为定时器T1的溢出标志位
  \item TF0 (TCON.5) 为定时器T0的溢出标志位
\end{itemize}
当计数器产生计数溢出时, 相应的溢出标志位由硬件置为1, 表示此时定时/计数已完成. 

软件查询时由软件负责清零; 中断查询时由硬件清零. 
\begin{itemize}
  \item TR1 (TCOM.4) 运行控制位
  \item TR0 (TCOM.6) 运行控制位
\end{itemize}
只能软件
\subsection{TMOD}不能位寻址, 只能一次性设置一个Byte
\begin{itemize}
  \item GATE 门控位, 外部请求信号INT0/INT1(高电平有效)和TR0/TR1共同启动定时器
  \item $C/ \bar{T}$ 0为定时器, 1为计数器
  \item 设定工作方式
\end{itemize}
\section{定时器设计}
\begin{table}
  \centering
  \begin{tabular}{cc|c|cc}
    $M_1$&$M_0$&工作方式&$T_L$&$T_H$
    \\ 0&0&13 bit&低5 bit&高8 bit
  \end{tabular}
\end{table}
\section{13 bit工作模式}
溢出后计数器全清零; 
$$T_{\max}=2^{13}=8192$$
\begin{equation}
  \text{定时时间}=(T_{\max}-\text{计数初值}) \times T_{\text{oscillator}} \times 12
\end{equation}
\section{16 bit工作模式}
溢出后计数器全清零; 
$$T_{\max}=2^{13}=8192$$
\section{8 bit工作模式}
自动重载初值, 免于反复设置初值的工作. 

通常时作为串行口的波特率发生器使用. 
\section{双8 bit工作模式}
你还真没啥用

\paragraph{例题}震荡频率为6MHz, 使用定时器1以方式0(13 bit)产生周期为 200 $\mu s$ 的等宽正方形脉冲, 由P1.0输出. 
先去算初值. 
\begin{align*}
  T&=(T_{\max}-T_0)\cdot T_{\text{osc}}\cdot 12\\
  \frac{200}{2}\mu s&=(8192-T_0)\cdot (\frac{1}{6}\cdot 12)\mu s
\end{align*}
因为周期是$200\mu s$, 就相当于$100\mu s$变换一次. 

可以解得$T_0=8142$
但是初值是要分别赋给$T_H$ (高8 bit)和$T_L$ (低5 bit)
\begin{align*}
  T_0=8142=\underset{T_H}{11111110}\; \underset{T_L}{01110}=\text{0xfe 0x0e}
\end{align*}
然后对TMOD寄存器做初始化$M_1M_0=\text{0b00}$, 定时器$C/\bar{T}=0$

然后对TCON初始化$TR1=1$启动, $TR0=0$停止

\begin{minted}{nasm}
        MOV TMOD, #00H
        MOV TH1, #0FEH
        MOV TL1, #0EH ;设定初值
        SETB TR1 ;开定时器1
  LOOP: JBC TF1, VAL
        SJMP LOOP
   VAL: MOV TH1, #0FEH
        MOV TL1, #0EH ;定时结束, 重新设定初值
        CLR TF1 ;可选, 前面使用JBC会自动清零
        CPL P1.0
        SJMP LOOP
\end{minted}
对应的伪C代码为
\begin{minted}{cpp}
register.TMOD=0x00;
register.TH1=0xfe;
register.TL1=0x0e;
register.TCON.TR1=1;
do{
  loop:
  do{
  val:
    register.TH1=0xfe;
    register.TL1=0x0e;
    ~P1.0;
    register.TCON.TF1=0;
  }while(register.TCON.TF1!=0); //Overflow时TF1为1, 定时结束
}while(1);
\end{minted}
或者更加像汇编的伪C
\begin{minted}{cpp}
  register.TMOD=0x00;
  register.TH1=0xfe;
  register.TL1=0x0e;
  register.TCON.TR1=1;
  do{
    loop:
      if(register.TCON.TF1==0){
        goto loop;
      }
      register.TH1=0xfe;
      register.TL1=0x0e;
      ~P1.0;
      register.TCON.TF1=0;
  }while(1);
\end{minted}
\section{计时器和循环共同使用}
若晶振频率为12MHz, 最大只能计
\begin{equation}
  T=T_{\max}\cdot 1\mu s\approx 65ms
\end{equation}
大于这个数的话就没办法只用计时器了, 必须和循环配合
\paragraph{例题}12MHz, 产生周期为2s的等宽正方形脉冲

可以采用50ms$\times$20来设计, 那么持续时间就为50ms=5e4$\mu s$, 解得初值为15536. $M_1 M_0=01\Rightarrow TMOD=01H$
\begin{minted}{nasm}
      MOV TMOD, #01H
      MOV TH0, #3CH ;设定初值
      MOV TL0, #0B0H
      SETB TR0 ;开定时器0
      MOV R2, #20
LOOP1:JB TF0, LOOP2
      SJMP LOOP1
LOOP2:MOV TH0, #3CH ;设定初值
      MOV TL0, #0B0H
      CLR TF0
      DJNZ R2, LOOP1
      CPL P1.0
      MOV R2, #20
      SJMP LOOP1
\end{minted}
伪C代码
\begin{minted}[]{cpp}
register.TMOD=0x10;
register.TH0=0x3c;
register.TL0=0xb0;
register.TCON.TR0=1;
register.R2=20;
loop1:
  if(register.TCON.TF0==0){
    goto loop1;
  }
loop2:
  register.TH0=0x3c;
  register.TL0=0xb0;
  register.TCON.TF0=1;
  if(--register.R2==0){
    goto loop1;
  }
  ~P1.0;
  register.R2=20;
  goto loop1;
\end{minted}
这是什么见鬼的玩意, 让我们用人话写
\begin{minted}[]{cpp}
register.TMOD=0x10;
register.TH0=0x3c;
register.TL0=0xb0;
register.TCON.TR0=1;
register.R2=20;
do{
  do{
    loop1:
      if(register.TCON.TF0==0){
        goto loop1;
      }
      register.TH0=0x3c;
      register.TL0=0xb0;
      register.TCON.TF0=0;
      register.R2--;
  }while(register.R2!=0);
  register.R2=20;
  ~P1.0;
}while(1);
\end{minted}
\section{中断方式实现}
不需要手动查询, 把查询交给了中断而非使用像这样的软件查询
\begin{minted}[]{nasm}
  LOOP1: JB TF0, LOOP2
         SJMP LOOP1
  LOOP2: MOV TH1, #0FCH
         MOV TL1, #03H
         CLR TF0
         ;......DO YOUR THINGS
         SJMP LOOP1
\end{minted}
以下是采用中断的写法
\begin{minted}[]{nasm}
      ORG 0000H
      LJMP MAIN
      ORG 001BH
      LJMP TIMER1
      ORG 0030H
MAIN: MOV TMOD, #00H
      MOV TH1, #0FCH
      MOV TL1, #03H
      SETB EA
      SETB ET1
      SETB TR1
      SJMP $ ;表示反复执行这一行, 或者说什么都不做; 停在这等中断就够了
      ; 等价于 LOOP: SJMP LOOP
TIMER1:
      MOV TH1, #0FCH
      MOV TL1, #03H
      CPL P1.0
      RETI
\end{minted}
\chapter{Serial}
\section{波特率}
因为是二进制, 所以波特率就是比特率
\begin{equation}
  1 \text{ Baud}=1\text{ bit/s}
\end{equation}
为了减小波特率误差
\begin{equation}
  f_\text{osc}=11.0592\text{MHz}
\end{equation}
表示串行口移位脉冲频率的高低
\section{SBUF}
发送(TX)接收(RX)寄存器; 虽然写着是一样但是不是同一个玩意? 
\begin{minted}{nasm}
  MOV SBUF,A ;写「发送」寄存器
  MOV A,SBUF ;读「接收」寄存器
\end{minted}
\section{SCON}
\paragraph{SM1, SM0} Serial的工作方式. (决定每一帧的大小和Baud)
\begin{itemize}
  \item 00 8 bit 同步移位寄存器 $R_B=\frac{f_\text{oscillation}}{12}$
  \item 01 10 bit 异步收发, 波特率由定时器1控制(可变)
  \item 10 11 bit 异步收发, $R_B=\frac{f_\text{oscillation}}{32}$或者$\frac{f_\text{oscillation}}{64}$
  \item 11 11 bit 异步收发, 波特率由定时器1控制 (可变)
\end{itemize}
\paragraph{REN} 允许接收
\paragraph{TI} 最后一个数据 bit 被发送完成后, 由硬件置位. (置为1)
\paragraph{RI} 采样到最后一个数据 bit 为有效后, 由硬件置位. (置为1)

别忘了设IE.ES 打开串行中断
\section{工作方式}
只能用定时器1, 不能用定时器0
\subsection{方式0--8 bit无启停 (固定波特率)}
8 bit, 不设起始/停止位. 先发送/接收最低位. 
\begin{equation}
  R_B=\frac{f_\text{oscillation}}{12}
\end{equation}
\subsection{方式1--10 bit带启停 (定时器波特率)}
10 bit 为一帧, 起始位0, 停止位1, 中间8 bit 数据位. 先发送/接收最低位. 

定时器用方式2 (8 bit 自动重载初值)
\begin{equation}
  \text{溢出周期}=\text{定时时间}=(256-\text{初值})\times T_{\text{oscillation}}\cdot 12
\end{equation}
溢出速率为溢出周期的倒数
\begin{equation}
  R_B=\frac{2^{\text{SMOD}}}{32}\times \frac{1}{\text{T1溢出周期}} 
\end{equation}
也就是说, 计算T1的初值实现波特率的设置

定时器初值的公式就是
\begin{equation}
  X=256-\frac{ f_\text{oscillation}\cdot 2^{\text{SMOD}}}{384\times R_B}
\end{equation}
一般假设SMOD为0
\subsection{方式2--11 bit带启停校验位 (固定波特率)}
SMOD为0时乘1, SMOD为1时乘2. 
\begin{equation}
  R_B=2^{\text{SMOD}}\times\frac{f_\text{oscillation}}{64}
\end{equation}
停止位前面加一个奇偶校验位. 
\subsection{方式3--11 bit带启停校验位 (定时器波特率)}
参考方式1
\section{发送}
初始化
\begin{minted}[]{nasm}
  MAIN:
    MOV SCON,#;所启用的串口
    MOV PCON,#80H;设置SMOD #00H
    MOV TMOD,#20H;设置T1工作状态
    MOV TH1, #;你的初值
    MOV TL1, #;你的初值
    SETB TR1 ;开定时器T1
    SETB EA ;开总中断
    SETB ES ;开串行中断
\end{minted}
\subsection{查询方式}
\begin{minted}[]{nasm}
  TX: MOV A,@R0
      MOV SBUF,A
  WAIT:
      JBC TI,NEXT
      SJMP WAIT
  NEXT:
      INC R0
      SJMP TX
\end{minted}
\subsection{中断方式}
\begin{minted}{nasm}
      ORG 0023H
      AJMP TxInterruption
  MAIN:;初始化略
    TX:
      MOV A,@R0
      MOV SBUF,A
      SJMP $ ;死循环, 等中断什么都不做
TxInterruption:
      CLR TI ;中断触发之后得手动清零
      INC R0 ;地址加一
      MOV A,@R0 ;取RAM数据
      MOV SBUF,A ;发出去
      RETI ;中断返回
\end{minted}
\section{接收}
\subsection{查询方式}
\begin{minted}[]{nasm}
  HOLD:
      JBC RI,NEXT ;一直查询是否接收到有效数据帧, 若是则跳转到NEXT
      SJMP WAIT
  NEXT:
      MOV A,SBUF
      MOV @R0,A
      INC R0
      SJMP WAIT

\end{minted}
\subsection{中断方式}
\begin{minted}[]{nasm}
      ORG 0023H
      AJMP RxInterruption
  MAIN:;初始化略
      SJMP $;什么都不做
RxInterruption:
      CLR RI;中断触发之后得手动清零
      MOV A,SBUF
      MOV @R0,A
      INC R0
      RETI
\end{minted}
\chapter{常见套路}
\section{软件延时}
软件延时50ms. 

执行一条DJNZ耗费两个机器周期\footnote{一个机器周期有12个振荡周期}. 若晶振为12MHz, 那么一个机器周期就是$1\mu s$, 俩就是2$\mu s$

若我要延时50ms
\begin{minted}[]{nasm}
  D50ms:  MOV R7,#200 ;循环200次, 执行时间1mus
      L1: MOV R6,#125 ;循环125次
      L2: DJNZ R6,L2  ;L2这个循环得跑125*2=250mus
          DJNZ R7,L1  ;200*(250mus+2mus) 执行本条指令的时间也算在内
          RET
\end{minted}
\section{中断延时}


\end{document}